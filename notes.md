# [Learn cpp](https://www.learncpp.com/)

[C++ Reference](https://en.cppreference.com/w/)

[C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)

Started: 2024-09-03

# [Chapter 0: Introduction](https://www.learncpp.com/cpp-tutorial/introduction-to-these-tutorials/)

## C and C++’s philosophy

The underlying design philosophy of C and C++ can be summed up as "trust the programmer" -- which is both wonderful and dangerous. C++ is designed to allow the programmer a high degree of freedom to do what they want. However, this also means the language often won’t stop you from doing things that don’t make sense, because it will assume you’re doing so for some reason it doesn’t understand. There are quite a few pitfalls that new programmers are likely to fall into if caught unaware. This is one of the primary reasons why knowing what you shouldn’t do in C/C++ is almost as important as knowing what you should do.

## C++ development

![workflow](images/dev_workflow.png)

### Step 1: Define the problem that you would like to solve

This is the "what" step, where you figure out what problem you are intending to solve. Coming up with the initial idea for what you would like to program can be the easiest step, or the hardest. But conceptually, it is the simplest. All you need is an idea that can be well defined, and you’re ready for the next step.

### Step 2: Determine how you are going to solve the problem

This is the "how" step, where you determine how you are going to solve the problem you came up with in step 1. It is also the step that is most neglected in software development. The crux of the issue is that there are many ways to solve a problem -- however, some of these solutions are good and some of them are bad. Too often, a programmer will get an idea, sit down, and immediately start coding a solution. This often generates a solution that falls into the bad category.

Typically, good solutions have the following characteristics:

- They are straightforward (not overly complicated or confusing).
- They are well documented (especially around any assumptions being made or limitations).
- They are built modularly, so parts can be reused or changed later without impacting other parts of the program.
- They are robust, and can recover or give useful error messages when something unexpected happens.

When you sit down and start coding right away, you’re typically thinking "I want to do <something>", so you implement the solution that gets you there the fastest. This can lead to programs that are fragile, hard to change or extend later, or have lots of bugs. A bug is any kind of programming error that prevents the program from operating correctly.

Consequently, it’s worth your time to spend a little extra time up front (before you start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.

### Step 3: Write the program
**Best practice**

Name the first/primary source code file in each program main.cpp. This makes it easy to determine which source code file is the primary one.

### Step 4: Compiling your source code

In order to compile C++ source code files, we use a C++ compiler. The C++ compiler sequentially goes through each source code (.cpp) file in your program and does two important tasks:

First, the compiler checks your C++ code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error (and the corresponding line number) to help pinpoint what needs fixing. The compilation process will also be aborted until the error is fixed.

Second, the compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an object file. The object file also contains metadata that is required or useful in subsequent steps.

Object files are typically named name.o or name.obj, where name is the same name as the .cpp file it was produced from.

### Step 5: Linking object files and libraries

After the compiler has successfully finished, another program called the linker kicks in. The linker’s job is to combine all of the object files and produce the desired output file (typically an executable file). This process is called linking.

First, the linker reads in each of the object files generated by the compiler and makes sure they are valid.

Second, the linker ensures all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in a different .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.

Third, the linker also is capable of linking library files. A library file is a collection of precompiled code that has been "packaged up" for reuse in other programs.

### Steps 6 & 7: Testing and Debugging

This is the fun part! You are now able to run your executable and see what it does!

Once you can run your program, then you can test it. Testing is the process of assessing whether your software is working as expected. Basic testing typically involves trying different input combinations to ensure the software behaves correctly in different cases.

If the program does not behave as expected, then you will have to do some debugging, which is the process of finding and fixing programming errors.

## Compiler configuration
See `ch00/makefile` for the configuration of the compiler.


# [Chapter 1: C++ Basics](https://www.learncpp.com/cpp-tutorial/statements-and-the-structure-of-a-program/)

## Statements and the structure of a program

### Statements
A statement is a type of instruction that causes the program to perform some action. Types of statements:
- Declaration statements
    - Definition statements
- Jump statements
- Expression statements
- Compound statements
- Selection statements (conditionals)
- Iteration statements (loops)
- Try blocks

### Functions and the main function
A function is a collection of statements that get executed sequentially. Every C++ program must have a special function named **main**. When the program is run, the statements inside of `main` are executed in sequential order. The name of a function (or object, type, template, etc…) is called its identifier.

### Dissecting Hello world!
```cpp
#include <iostream>             // 1
                                // 2
int main()                      // 3
{                               // 4
   std::cout << "Hello world!"; // 5
   return 0;                    // 6
}                               // 7
```
- Line 1: is a special type of line called a preprocessor directive, indicating that we would like to use the contents of the `iostream` library.
- Line 3: define a function with identifier `main` that returns an integer.
- Line 4 & 7: define the body of the `main` function.
- Line 5: is a statement that **c**haracter **out**put to the console using the `<<` operator.
- Line 6: is a statement that returns the integer value `0` to the operating system, indicating that the program completed successfully.

## Comments
- Single line comments: `//`
- Multi-line comments: 
```cpp
/* This is a multi-line comment.
 * the matching asterisks to the left
 * can make this easier to read
 */
```
Comments should be used for three things: 
1. At the library, program, or function level, use comments to describe **what**.
1. Inside the library, program, or function, use comments to describe **how**.
1. At the statement level, use comments to describe **why**.

## Introduction to objects and variables
### Data and values
In computing, data is any information that can be manipulated: reading, changing, and writing. The "Hello world" program manipulates the data "Hello World!" by sending it to the monitor to be displayed.

A single piece of data is called a value. Common examples of values include letters (e.g. `a`), numbers (e.g. `5`), and text (e.g. `Hello`).

### Random Access Memory (RAM)
You can think of RAM as a series of numbered boxes that can be used to store data while the program is running.

### Objects and variables
In C++, direct memory access is discouraged. Instead, we access memory indirectly through an object. An object is a region of storage (usually memory) that can store a value, and has other associated properties. Rather than say "go get the value stored in box number 7532", we can say, "go get the value stored by this object" and let the compiler figure out where and how to retrieve the value.

An **object** is used to store a value in memory. A **variable** is an object that has an identifier.

### Variable instantiation
```cpp
int x; 
```
At **compile time**, this statement defines a variable, giving it the identifier `x`, and the data type `int`. At **runtime**, the variable will be instantiated (created and assigned a memory address). An instantiated object is sometimes called an **instance**.

### Data types
A **data type** (more commonly just called a **type**) determines what kind of value (e.g. a number, a letter, text, etc…) the object will store. In C++, the type of an object **must be known at compile time**, and that type can not be changed without recompiling the program (static typing).

### Defining variables
```cpp
int a, double b; // wrong (compiler error)

int a; double b; // correct (but not recommended)
int a, b; // correct (but not recommended)

// correct and recommended (easier to read)
int a;
int b;
double c;
```
### Summary
In C++, we use objects to access memory. A named object is called a variable. Variables have an identifier, a type, and a value (and some other attributes that aren’t relevant here). A variable’s type is used to determine how the value in memory should be interpreted.

## [Variable assignment and initialization](https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/)

### Variable assignment
Is done using the assignment operator `=`. The value on the right side of the assignment operator is assigned to the variable on the left side.

### Variable initialization
Is the process of giving a variable an initial value. Different forms of initialization:
```cpp
int a;         // default-initialization (no initializer)

// Traditional initialization forms:
int b = 5;     // copy-initialization (initial value after equals sign)
int c ( 6 );   // direct-initialization (initial value in parenthesis)

// Modern initialization forms (preferred):
int d { 7 };   // direct-list initialization (initial value in braces)
int f {};      // value-initialization (empty braces)
```
- Copy-initialization is also used whenever values are implicitly copied, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.
- One of the reasons direct-initialization had fallen out of favor is because it makes it hard to differentiate variables from functions.
- List-initialization was introduced to provide a consistent initialization syntax (which is why it is sometimes called “uniform initialization”) that makes it clear we’re doing initialization.

The primary benefit of list-initialization is that “narrowing conversions” are disallowed. This means that if you try to list-initialize a variable using a value that the variable can not safely hold, the compiler is required to produce a diagnostic (usually an error). For example:
```cpp
int main()
{
    // An integer can only hold non-fractional values
    int w1 { 4.5 }; // compile error: list init does not allow narrowing conversion of 4.5 to 4

    int w2 = 4.5;   // compiles: copy-init initializes width with 4
    int w3(4.5);    // compiles: direct-init initializes width with 4

    w1 = 4.5;       // okay: copy-assignment allows narrowing conversion of 4.5 to 4

    return 0;
}
```

List-initialization is generally preferred over the other initialization forms because it works in most cases (and is therefore most consistent), it disallows narrowing conversions (which we normally don’t want), and it supports initialization with a list of values (something we’ll cover in a future lesson).

Use direct-list-initialization when you’re actually using the initial value. Use value-initialization when the object’s value is temporary and will be replaced:
```cpp
int x { 0 };    // direct-list-initialization with initial value 0
std::cout << x; // we're using that 0 value here

int x {};      // value initialization
std::cin >> x; // we're immediately replacing that value so an explicit 0 would be meaningless
```

**Initialize your variables upon creation. You may eventually find cases where you want to ignore this advice for a specific reason (e.g. a performance critical section of code that uses a lot of variables), and that’s okay, as long as the choice is made deliberately.**

[[maybe_unused]] attribute:
```cpp
#include <iostream>

int main()
{
    [[maybe_unused]] double pi { 3.14159 };  // Don't complain if pi is unused
    [[maybe_unused]] double gravity { 9.8 }; // Don't complain if gravity is unused
    [[maybe_unused]] double phi { 1.61803 }; // Don't complain if phi is unused

    std::cout << pi << '\n';
    std::cout << phi << '\n';

    // The compiler will no longer warn about gravity not being used

    return 0;
}
```

Additionally, the compiler will likely optimize these variables out of the program, so they have no performance impact.

The [[maybe_unused]] attribute should only be applied selectively to variables that have a specific and legitimate reason for being unused (e.g. because you need a list of named values, but which specific values are actually used in a given program may vary).

## [Introduction to iostream: cout, cin, and endl](https://www.learncpp.com/cpp-tutorial/introduction-to-iostream-cout-cin-and-endl/)

### The input/output library
#### std::cout and std::endl

`std::cout` used with the insertion operator `<<` to output data to the console. Concatenation is possible.
```cpp
#include <iostream> // for std::cout and std::endl

int main()
{
    std::cout << "Hi!" << std::endl; // std::endl will cause the cursor to move to the next line and flush the buffer
    std::cout << "My name is Alex." << std::endl;

    return 0;
}
```

`std::cout` is buffered. This means that the data you send to `std::cout` is not immediately displayed on the screen. Instead, it is stored in a region of memory set aside to collect such requests (called a **buffer**) until the buffer is full, or until you flush the buffer.

Writing data to a buffer is typically fast, whereas transferring a batch of data to an output device is comparatively slow. Buffering can significantly increase performance by batching multiple output requests together to minimize the number of times output has to be sent to the output device.

To output a newline without flushing the output buffer, we use `\n` (inside either single or double quotes), which is a special symbol that the compiler interprets as a newline character. `\n` moves the cursor to the next line of the console without causing a flush, so it will typically perform better. `\n` is also more concise to type and can be embedded into existing double-quoted text.

```cpp
#include <iostream> // for std::cout

int main()
{
    int x{ 5 };
    std::cout << "x is equal to: " << x << '\n'; // single quoted (by itself) (conventional)
    std::cout << "Yep." << "\n";                 // double quoted (by itself) (unconventional but okay)
    std::cout << "And that's all, folks!\n";     // between double quotes in existing text (conventional)
    return 0;
}
```

In C++, we use single quotes to represent single characters (such as 'a' or '$'), and double-quotes to represent text (zero or more characters). Single quotes should be preferred in non-output cases.

#### std::cin
```cpp
#include <iostream>  // for std::cout and std::cin

int main()
{
    std::cout << "Enter two numbers separated by a space: ";

    int x{}; // define variable x to hold user input (and value-initialize it)
    int y{}; // define variable y to hold user input (and value-initialize it)
    std::cin >> x >> y; // get two numbers and store in variable x and y respectively

    std::cout << "You entered " << x << " and " << y << '\n';

    return 0;
}
```
Each line of input data in the input buffer is terminated by a '\n' character. `std::cin` is buffered because it allows us to separate the entering of input from the extract of input. We can enter input once and then perform multiple extraction requests on it.


## [Uninitialized variables and undefined behavior](https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/)

### Uninitialized variables
- Initialized = The object is given a known value at the point of definition.
- Assignment = The object is given a known value beyond the point of definition.
- Uninitialized = The object has not been given a known value yet.

### Undefined behavior
Code implementing undefined behavior may exhibit any of the following symptoms:
- Your program produces different results every time it is run.
- Your program consistently produces the same incorrect result.
- Your program behaves inconsistently (sometimes produces the correct result, sometimes not).
- Your program seems like it’s working but produces incorrect results later in the program.
- Your program crashes, either immediately or later.
- Your program works on some compilers but not others.
- Your program works until you change some other seemingly unrelated code.
Or, your code may actually produce the correct behavior anyway.

Unspecified behavior is almost identical to implementation-defined behavior in that the behavior is left up to the implementation (a specific compiler and the associated standard library it comes with) to define, but the implementation is not required to document the behavior.

Avoid implementation-defined and unspecified behavior whenever possible, as they may cause your program to malfunction on other implementations.

## [Keywords and naming identifiers](https://www.learncpp.com/cpp-tutorial/keywords-and-naming-identifiers/)

### Keywords
C++ reserves a set of 92 words (as of C++23) for its own use. These words are called keywords (or reserved words), and each of these keywords has a special meaning within the C++ language:

|               |               |               |               |
|---------------|---------------|---------------|---------------|
| alignas       | alignof       | and           | and_eq        |
| asm           | auto          | bitand        | bitor         |
| bool          | break         | case          | catch         |
| char          | char8_t       | char16_t      | char32_t      |
| class         | compl         | concept       | const         |
| consteval     | constexpr     | constinit     | const_cast    |
| continue      | co_await      | co_return     | co_yield      |
| decltype      | default       | delete        | do            |
| double        | dynamic_cast  | else          | enum          |
| explicit      | export        | extern        | false         |
| float         | for           | friend        | goto          |
| if            | inline        | int           | long          |
| mutable       | namespace     | new           | noexcept      |
| not           | not_eq        | nullptr       | operator      |
| or            | or_eq         | private       | protected     |
| public        | register      | reinterpret_cast | requires   |
| return        | short         | signed        | sizeof        |
| static        | static_assert | static_cast   | struct        |
| switch        | template      | this          | thread_local  |
| throw         | true          | try           | typedef       |
| typeid        | typename      | union         | unsigned      |
| using         | virtual       | void          | volatile      |
| wchar_t       | while         | xor           | xor_eq        |

C++ also defines special identifiers: override, final, import, and module. These have a specific meaning when used in certain contexts but are not reserved otherwise.

### Identifier naming rules
- The identifier can not be a keyword. Keywords are reserved.
The identifier can only be composed of letters (lower or upper case), numbers, and - the underscore character. That means the name can not contain symbols (except the underscore) nor whitespace (spaces or tabs).
The identifier must begin with a letter (lower or upper case) or an underscore. It - can not start with a number.
C++ is case sensitive, and thus distinguishes between lower and upper case letters. - `nvalue` is different than `nValue` is different than `NVALUE`.

### Naming conventions

Avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.

Avoid abbreviations (unless they are common/unambiguous), they make your code harder to read. Code is read more often than it is written, the time you saved while writing the code is time that every reader, including the future you, wastes when reading it.

## [Whitespace and basic formatting](https://www.learncpp.com/cpp-tutorial/whitespace-and-basic-formatting/)


## [Introduction to literals and operators](https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/)
## [Introduction to expressions](https://www.learncpp.com/cpp-tutorial/introduction-to-expressions/)


## [Developing your first program](https://www.learncpp.com/cpp-tutorial/developing-your-first-program/)


# [Functions and Files](https://www.learncpp.com/cpp-tutorial/introduction-to-functions/)